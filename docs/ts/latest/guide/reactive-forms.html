<!DOCTYPE html><html lang="en" ng-app="angularIOApp" itemscope itemtype="http://schema.org/Framework"><!-- template: public/docs/_layout--><head><title>Reactive Forms - ts - GUIDE</title><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="Angular is a development platform for building mobile and desktop web applications"/><meta name="keywords" content="Angular, AngularJS, AngularDart, Javscript, Dart, Framework, JavaScript MVC, Google"/><meta name="robots" content="all"/><meta name="referrer" content="origin"/><meta name="viewport" id="viewport" content="width=device-width, initial-scale=1"/><meta property="og:title" content="Angular"/><meta property="og:image" content="/resources/images/logos/standard/shield-large.png"/><meta property="og:image:type" content="image/png"/><meta property="og:image:width" content="184"/><meta property="og:image:height" content="200"/><meta property="og:description" content="Angular is a development platform for building mobile and desktop web applications"/><meta itemprop="name" content="Angular"/><meta itemprop="description" content="Angular is a development platform for building mobile and desktop web applications"/><meta itemprop="image" content="https://angular.io/resources/images/logos/standard/shield-large.png"/><link rel="icon" type="image/x-icon" href="/resources/images/icons/favicon.ico"/><link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/angular_material/1.0.0/angular-material.min.css"/><link href="https://fonts.googleapis.com/css?family=Roboto:400,300,500,400italic,700" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"/><link rel="stylesheet" href="/resources/css/vendor/icomoon/style.css"/><link rel="stylesheet" href="/resources/css/vendor/animate.css"/><link rel="stylesheet" href="/resources/css/main.css"/><!-- MOBILE ICONS -->
<link rel="apple-touch-icon" sizes="57x57" href="/resources/images/favicons/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/resources/images/favicons/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/resources/images/favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/resources/images/favicons/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/resources/images/favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/resources/images/favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/resources/images/favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/resources/images/favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/resources/images/favicons/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-194x194.png" sizes="194x194">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/resources/images/favicons/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="/resources/images/favicons/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="/resources/images/favicons/manifest.json"></head><body ng-controller="AppCtrl as appCtrl" class="l-offset-nav l-offset-side-nav"><nav data-swiftype-index="false" scroll-y-offset-element="scroll-y-offset-element" class="main-nav l-pinned-top l-layer-5"><h1><a href="/" md-button>Angular <sup>by Google</sup></a></h1><button aria-label="View Menu" ng-click="appCtrl.toggleMainMenu($event)" md-button="md-button" class="main-nav-button main-nav-mobile-trigger l-right">Site Menu <span class="icon icon-arrow-drop-down"></span></button><ul ng-class="appCtrl.showMainNav ? 'is-visible' : ''"><li class="l-left"><a class="main-nav-button" href="/features.html" md-button>Features</a></li><li class="l-left"><a class="main-nav-button" href="/docs/ts/latest/" md-button>Docs</a></li><li class="l-left"><a class="main-nav-button" href="/events.html" md-button>Events</a></li><li class="l-right"><a class="main-nav-button" href="/docs/ts/latest/quickstart.html" md-button>Get Started</a></li></ul></nav><!-- Include this file ONLY when current.path[2] is defined--><nav data-swiftype-index="false" ng-class="appCtrl.showDocsNav ? 'is-visible' : ''" class="sidenav l-pinned-left l-layer-4 l-offset-nav"><!-- SEARCH BAR--><header class="sidenav-search st-input-wrapper"><div class="st-input-inner"><label for="search-io" class="is-hidden">Search Docs</label><input type="text" placeholder="SEARCH DOCS..." class="st-default-search-input"/></div><button aria-label="View Docs Menu" ng-click="appCtrl.toggleDocsMenu($event)" md-button="md-button" class="mobile-trigger button">Docs <span class="icon icon-arrow-drop-down"></span></button></header><ul class="sidenav-links"><li class="sidenav-section no-border"><a href="/docs/ts/latest/" class="nav-title">Docs Home</a></li><!-- CORE DOCUMENTATION--><li class="sidenav-section-divider"><h3>Core Documentation</h3></li><li class="sidenav-section"><a href="/docs/ts/latest/quickstart.html" title="Quickstart" class="nav-title ">Quickstart</a></li><li class="sidenav-section"><a href="/docs/ts/latest/cli-quickstart.html" title="CLI Quickstart" class="nav-title ">CLI Quickstart</a></li><li class="sidenav-section"><a href="/docs/ts/latest/guide/" title="How to read and use this documentation." class="nav-title is-parent ">Guide<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-ordered-lists is-hidden"><ul><li class="nav-list-item "><a href="/docs/ts/latest/guide/" title="How to read and use this documentation.">1. Overview</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/setup.html" title="Install the Angular QuickStart seed for faster, more efficient development on your machine.">2. Setup</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/learning-angular.html" title="A suggested path through the documentation for Angular newcomers.">3. Learning Angular</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/architecture.html" title="The basic building blocks of Angular applications.">4. Architecture</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/appmodule.html" title="Tell Angular how to construct and bootstrap the app in the root &quot;AppModule&quot;.">5. The Root Module</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/displaying-data.html" title="Property binding helps show app data in the UI.">6. Displaying Data</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/user-input.html" title="User input triggers DOM events. We listen to those events with event bindings that funnel updated values back into our components and models.">7. User Input</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/forms.html" title="A form creates a cohesive, effective, and compelling data entry experience. An Angular form coordinates a set of data-bound user controls, tracks changes, validates input, and presents errors.">8. Forms</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/dependency-injection.html" title="Angular's dependency injection system creates and delivers dependent services &quot;just-in-time&quot;.">9. Dependency Injection</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/template-syntax.html" title="Learn how to write templates that display data and consume user events with the help of data binding.">10. Template Syntax</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/cheatsheet.html" title="Cheat Sheet">11. Cheat Sheet</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/style-guide.html" title="Write Angular with style.">12. Style Guide</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/glossary.html" title="Brief definitions of the most important words in the Angular vocabulary.">13. Glossary</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/change-log.html" title="An annotated history of recent documentation improvements.">14. Change Log</a></li></ul></div></li><li class="sidenav-section no-border"><a href="/docs/ts/latest/api/" title="API Reference" class="nav-title ">API Reference</a></li><!-- ADVANCED DOCUMENATION--><li class="sidenav-section-divider"><h3>Additional Documentation</h3></li><li class="sidenav-section"><a href="/docs/ts/latest/tutorial/" title="The Tour of Heroes tutorial takes you through the steps of creating an Angular application in TypeScript." class="nav-title is-parent ">Tutorial<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-ordered-lists is-hidden"><ul><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/" title="The Tour of Heroes tutorial takes you through the steps of creating an Angular application in TypeScript.">1. Introduction</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt1.html" title="We build a simple hero editor.">2. The Hero Editor</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt2.html" title="We build a master/detail page with a list of heroes.">3. Master/Detail</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt3.html" title="We refactor the master/detail view into separate components.">4. Multiple Components</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt4.html" title="We create a reusable service to manage our hero data calls.">5. Services</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt5.html" title="We add the Angular Router and learn to navigate among the views.">6. Routing</a></li><li class="nav-list-item "><a href="/docs/ts/latest/tutorial/toh-pt6.html" title="We convert our service and components to use Angular's HTTP service.">7. HTTP</a></li></ul></div></li><li class="sidenav-section"><a href="/docs/ts/latest/guide/animations.html" title="A guide to Angular's animation system." class="nav-title is-parent is-selected">Advanced<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-unordered-lists"><ul><li class="nav-list-item "><a href="/docs/ts/latest/guide/animations.html" title="A guide to Angular's animation system.">Animations</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/attribute-directives.html" title="Attribute directives attach behavior to elements.">Attribute Directives</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/browser-support.html" title="Browser support and polyfills guide.">Browser support</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/component-styles.html" title="Learn how to apply CSS styles to components.">Component Styles</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/deployment.html" title="Learn how to deploy your Angular app.">Deployment</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/hierarchical-dependency-injection.html" title="Angular's hierarchical dependency injection system supports nested injectors in parallel with the component tree.">Hierarchical Injectors</a></li><li class="nav-list-item is-selected"><a href="/docs/ts/latest/guide/reactive-forms.html" title="Create a reactive form using FormBuilder, groups, and arrays.">Reactive Forms</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/server-communication.html" title="Use an HTTP Client to talk to a remote server.">HTTP Client</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/lifecycle-hooks.html" title="Angular calls lifecycle hook methods on directives and components as it creates, changes, and destroys them.">Lifecycle Hooks</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/ngmodule.html" title="Define application modules with @NgModule.">NgModules</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/npm-packages.html" title="Recommended npm packages, and how to specify package dependencies.">Npm Packages</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/pipes.html" title="Pipes transform displayed values within a template.">Pipes</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/router.html" title="Discover the basics of screen navigation with the Angular Router.">Routing &amp; Navigation</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/security.html" title="Developing for content security in Angular applications.">Security</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/setup-systemjs-anatomy.html" title="Inside the local development environment for SystemJS.">Setup Anatomy</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/structural-directives.html" title="Angular has a powerful template engine that lets us easily manipulate the DOM structure of our elements.">Structural Directives</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/testing.html" title="Techniques and practices for testing an Angular app.">Testing</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/typescript-configuration.html" title="TypeScript configuration for Angular developers.">TypeScript Configuration</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/upgrade.html" title="Incrementally upgrade an AngularJS application to Angular.">Upgrading from AngularJS</a></li><li class="nav-list-item "><a href="/docs/ts/latest/guide/webpack.html" title="Create Angular applications with a Webpack based tooling.">Webpack: an introduction</a></li></ul></div></li><li class="sidenav-section"><a href="/docs/ts/latest/cookbook/" title="A collection of recipes for common Angular application scenarios." class="nav-title is-parent ">Cookbook<img src="/resources/images/icons/ic_keyboard_arrow_down_black_24px.svg" class="inline-arrow-down-svg"/></a><div class="nav-unordered-lists is-hidden"><ul><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/" title="A collection of recipes for common Angular application scenarios.">Overview</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/aot-compiler.html" title="Learn how to use Ahead-of-time compilation.">Ahead-of-Time Compilation</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/ajs-quick-reference.html" title="Learn how AngularJS concepts and techniques map to Angular.">AngularJS to Angular</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/component-communication.html" title="Share information between different directives and components.">Component Interaction</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/dependency-injection.html" title="Techniques for Dependency Injection.">Dependency Injection</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/dynamic-component-loader.html" title="Load components dynamically.">Dynamic Component Loader</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/dynamic-form.html" title="Render dynamic forms with FormGroup.">Dynamic Forms</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/form-validation.html" title="Validate user's form entries.">Form Validation</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/i18n.html" title="Translate the app's template text into multiple languages.">Internationalization (i18n)</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/ngmodule-faq.html" title="Answers to frequently asked questions about @NgModule.">NgModule FAQs</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/set-document-title.html" title="Setting the document or window title using the Title service.">Set the Document Title</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/ts-to-js.html" title="Convert Angular TypeScript examples into ES6 and ES5 JavaScript.">TypeScript to JavaScript</a></li><li class="nav-list-item "><a href="/docs/ts/latest/cookbook/visual-studio-2015.html" title="Use Visual Studio 2015 with the QuickStart files.">Visual Studio 2015 QuickStart</a></li></ul></div></li></ul><nav class="dropdown"><button aria-label="Select a version of Angular" md-button="md-button" ng-click="appCtrl.toggleVersionMenu($event)" class="dropdown-button">Angular for TypeScript  <span class="icon icon-arrow-drop-down"></span></button><div ng-click="appCtrl.toggleVersionMenu($event)" ng-show="appCtrl.showMenu" class="overlay ng-hide"></div><ul ng-class="appCtrl.showMenu ? 'is-visible' : ''" class="dropdown-menu"><li><a href="/docs/ts/latest/guide/reactive-forms.html" md-button>Angular for TypeScript </a></li><li><a href="/docs/js/latest/guide/reactive-forms.html" md-button>Angular for JavaScript </a></li></ul></nav></nav><script>// Could put in appCtrl but only needed here and clear here
(function scrollToSelectedLink() {
  var sideNav = document.getElementsByClassName('sidenav')[0];
  var link = sideNav.getElementsByClassName('is-selected')[0];
  if(link && link.offsetTop > window.innerHeight){
    sideNav.scrollTop = link.offsetTop - (window.innerHeight/2);
    //alert("offsetTop: " + link.offsetTop + " side-nav top is " + sideNav.scrollTop);
  }
})()</script><header class="hero background-sky"><h1 class="hero-title ">Reactive Forms </h1><div class="clear"></div></header><div class="banner"><p class="text-body">Create a reactive form using FormBuilder, groups, and arrays.</p></div><article class="l-content-small grid-fluid docs-content"><script>function why(id, backTo) {
  var id = "#"+id;
  var el = document.querySelector(id);
  el.hidden=el.hidden=!el.hidden;

  if (el.hidden && backTo){
    // the next line is required to work around a bug in WebKit (Chrome / Safari)
    location.href = "#";
    location.href =  "#" + backTo;
  }
}</script><script>function verbose(isVerbose) {
  isVerbose = !! isVerbose;
  var el = document.querySelector('button.verbose.off');
  el.style.display = isVerbose ? 'block' : 'none';
  var el = document.querySelector('button.verbose.on');
  el.style.display = isVerbose ? 'none' : 'block';

  CCSStylesheetRuleStyle('main','.l-verbose-section', 'display',
    isVerbose ? 'block' : 'none');
}
</script><script>function CCSStylesheetRuleStyle(stylesheet, selectorText, style, value){
  /* returns the value of the element style of the rule in the stylesheet
  *  If no value is given, reads the value
  *  If value is given, the value is changed and returned
  *  If '' (empty string) is given, erases the value.
  *  The browser will apply the default one
  *
  * string stylesheet: part of the .css name to be recognized, e.g. 'default'
  * string selectorText: css selector, e.g. '#myId', '.myClass', 'thead td'
  * string style: camelCase element style, e.g. 'fontSize'
  * string value optional : the new value
  */
  var CCSstyle = undefined, rules, sheet;
  for(var m in document.styleSheets){
    sheet = document.styleSheets[m];
    if(sheet.href && sheet.href.indexOf(stylesheet) != -1){
    rules = sheet[document.all ? 'rules' : 'cssRules'];
    for(var n in rules){
      console.log(rules[n].selectorText);
      if(rules[n].selectorText == selectorText){
        CCSstyle = rules[n].style;
        break;
      }
    }
    break;
    }
  }
  if(value == undefined)
    return CCSstyle[style]
  else
    return CCSstyle[style] = value
}
</script><p><em>Reactive forms</em> is an Angular technique for creating forms in a <em>reactive</em> style.
This guide explains reactive forms as you follow the steps to build a &quot;Hero Detail Editor&quot; form.</p>
<a id="toc"></a><h2 id="contents">Contents</h2>
<ul>
<li><a href="#intro">Introduction to reactive forms</a></li>
<li><a href="#setup">Setup</a></li>
<li><a href="#data-model">Create a data model</a></li>
<li><a href="#create-component">Create a <em>reactive forms</em> component</a></li>
<li><a href="#create-template">Create its template file</a></li>
<li><a href="#import">Import the <em>ReactiveFormsModule</em></a></li>
<li><a href="#update">Display the <em>HeroDetailComponent</em></a></li>
<li><a href="#formgroup">Add a FormGroup</a></li>
<li><a href="#json">Taking a look at the form model</a></li>
<li><a href="#formbuilder">Introduction to <em>FormBuilder</em></a></li>
<li><a href="#validators">Validators.required</a></li>
<li><a href="#grouping">Nested FormGroups</a></li>
<li><a href="#properties">Inspect <em>FormControl</em> properties</a></li>
<li><a href="#set-data">Set form model data using <em>setValue</em> and <em>patchValue</em></a></li>
<li><a href="#form-array">Use <em>FormArray</em> to present an array of <em>FormGroups</em></a></li>
<li><a href="#observe-control">Observe control changes</a></li>
<li><a href="#save">Save form data</a></li>
</ul>
<p>Try the <live-example plnkr="final" title="Reactive Forms (final) in Plunker">Reactive Forms live-example</live-example>.</p>
<p>You can also run the <live-example title="Reactive Forms Demo in Plunker">Reactive Forms Demo</live-example> version
and choose one of the intermediate steps from the &quot;demo picker&quot; at the top.</p>
<a id="intro"></a><h2 id="introduction-to-reactive-forms">Introduction to Reactive Forms</h2>
<p>Angular offers two form-building technologies: <em>reactive</em> forms and <em>template-driven</em> forms.
The two technologies belong to the <code>@angular/forms</code> library
and share a common set of form control classes.</p>
<p>But they diverge markedly in philosophy, programming style, and technique.
They even have their own modules: the <code>ReactiveFormsModule</code> and the <code>FormsModule</code>.</p>
<h3 id="_reactive_-forms"><em>Reactive</em> forms</h3>
<p>Angular <em>reactive</em> forms facilitate a <em>reactive style</em> of programming 
that favors explicit management of the data flowing between
a non-UI <em>data model</em> (typically retrieved from a server) and a 
UI-oriented <em>form model</em> that retains the states 
and values of the HTML controls on screen. Reactive forms offer the ease 
of using reactive patterns, testing, and validation.</p>
<p>With <em>reactive</em> forms, you create a tree of Angular form control objects
in the component class and bind them to native form control elements in the 
component template, using techniques described in this guide. </p>
<p>You create and manipulate form control objects directly in the 
component class. As the component class has immediate access to both the data 
model and the form control structure, you can push data model values into 
the form controls and pull user-changed values back out. The component can 
observe changes in form control state and react to those changes.</p>
<p>One advantage of working with form control objects directly is that value and validity updates 
are <a href="#async-vs-sync" title="Async vs sync">always synchronous and under your control</a>. 
You won&#39;t encounter the timing issues that sometimes plague a template-driven form
and reactive forms can be easier to unit test.</p>
<p>In keeping with the reactive paradigm, the component 
preserves the immutability of the <em>data model</em>,
treating it as a pure source of original values.
Rather than update the data model directly, 
the component extracts user changes and forwards them to an external component or service, 
which does something with them (such as saving them) 
and returns a new <em>data model</em> to the component that reflects the updated model state. </p>
<p>Using reactive form directives does not require you to follow all reactive priniciples, 
but it does facilitate the reactive programming approach should you choose to use it.</p>
<h3 id="_template-driven_-forms"><em>Template-driven</em> forms</h3>
<p><em>Template-driven</em> forms, introduced in the <a href="forms.html">Template guide</a>, take a completely different approach.</p>
<p>You place HTML form controls (such as <code>&lt;input&gt;</code> and <code>&lt;select&gt;</code>) in the component template and 
bind them to <em>data model</em> properties in the component, using directives 
like <code>ngModel</code>.</p>
<p>You don&#39;t create Angular form control objects. Angular directives 
create them for you, using the information in your data bindings. 
You don&#39;t push and pull data values. Angular handles that for you with <code>ngModel</code>.
Angular updates the mutable <em>data model</em> with user changes as they happen.</p>
<p>For this reason, the <code>ngModel</code> directive is not part of the ReactiveFormsModule.</p>
<p>While this means less code in the component class, 
<a href="#async-vs-sync" title="Async vs sync">template-driven forms are asynchronous</a>
which may complicate development in more advanced scenarios. </p>
<a id="async-vs-sync"></a><h3 id="async-vs-sync">Async vs. sync</h3>
<p>Reactive forms are synchronous. Template-driven forms are asynchronous. It&#39;s a difference that matters.</p>
<p>In reactive forms, you create the entire form control tree in code. 
You can immediately update a value or drill down through the descendents of the parent form 
because all controls are always available.</p>
<p>Template-driven forms delegate creation of their form controls to directives.
To avoid &quot;<em>changed after checked</em>&quot; errors, 
these directives take more than one cycle to build the entire control tree.
That means you must wait a tick before manipulating any of the controls
from within the component class.</p>
<p>For example, if you inject the form control with a <code>@ViewChild(NgForm)</code> query and examine it in the 
<a href="lifecycle-hooks.html#afterview" title="Lifecycle hooks guide: AfterView"><code>ngAfterViewInit</code> lifecycle hook</a>,
you&#39;ll discover that it has no children.
You must wait a tick, using <code>setTimeout</code>, before you can
extract a value from a control, test its validity, or set it to a new value.</p>
<p>The asynchrony of template-driven forms also complicates unit testing. 
You must wrap your test block in <code>async()</code> or <code>fakeAsync()</code> to 
avoid looking for values in the form that aren&#39;t there yet. 
With reactive forms, everything is available when you expect it to be.</p>
<h3 id="which-is-better-reactive-or-template-driven-">Which is better, reactive or template-driven?</h3>
<p>Neither is &quot;better&quot;.
They&#39;re two different architectural paradigms, 
with their own strengths and weaknesses.
Choose the approach that works best for you.
You may decide to use both in the same application.</p>
<p>The balance of this <em>reactive forms</em> guide explores the <em>reactive</em> paradigm and 
concentrates exclusively on reactive forms techniques. 
For information on <em>template-driven forms</em>, see the <a href="forms.html"><em>Forms</em></a> guide.</p>
<p>In the next section, you&#39;ll set up your project for the reactive form demo.
Then you&#39;ll learn about the <a href="#essentials">Angular form classes</a> and how to use them in a reactive form.</p>
<div class="l-main-section"></div><a id="setup"></a><h2 id="setup">Setup</h2>
<p>Follow the steps in the <a href="../setup.html" title="Setup guide"><em>Setup</em> guide</a> 
for creating a new project folder (perhaps called <code>reactive-forms</code>)
based on the <em>QuickStart seed</em>.</p>
<div class="l-main-section"></div><a id="data-model"></a><h2 id="create-a-data-model">Create a data model</h2>
<p>The focus of this guide is a reactive forms component that edits a hero.
You&#39;ll need a <code>hero</code> class and some hero data.
Create a new <code>data-model.ts</code> file in the <code>app</code> directory and copy the content below into it.</p>
<div class="code-example"><header><h4>src/app/data-model.ts</h4></header><code-example language="ts" format="">export class Hero {
  id = 0;
  name = &#39;&#39;;
  addresses: Address[];
}

export class Address {
  street = &#39;&#39;;
  city   = &#39;&#39;;
  state  = &#39;&#39;;
  zip    = &#39;&#39;;
}

export const heroes: Hero[] = [
  {
    id: 1,
    name: &#39;Whirlwind&#39;,
    addresses: [
      {street: &#39;123 Main&#39;,  city: &#39;Anywhere&#39;, state: &#39;CA&#39;,  zip: &#39;94801&#39;},
      {street: &#39;456 Maple&#39;, city: &#39;Somewhere&#39;, state: &#39;VA&#39;, zip: &#39;23226&#39;},
    ]
  },
  {
    id: 2,
    name: &#39;Bombastic&#39;,
    addresses: [
      {street: &#39;789 Elm&#39;,  city: &#39;Smallville&#39;, state: &#39;OH&#39;,  zip: &#39;04501&#39;},
    ]
  },
  {
    id: 3,
    name: &#39;Magneta&#39;,
    addresses: [ ]
  },
];

export const states = [&#39;CA&#39;, &#39;MD&#39;, &#39;OH&#39;, &#39;VA&#39;];
</code-example></div><p>The file exports two classes and two constants. The <code>Address</code> 
and <code>Hero</code> classes define the application <em>data model</em>. 
The <code>heroes</code> and <code>states</code> constants supply the test data. </p>
<div class="l-main-section"></div><a id="create-component"></a><h2 id="create-a-_reactive-forms_-component">Create a <em>reactive forms</em> component</h2>
<p>Make a new file called 
<code>hero-detail.component.ts</code> in the <code>app</code> directory and import these symbols:</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts</h4></header><code-example language="ts" format="">import { Component }              from &#39;@angular/core&#39;;
import { FormControl }            from &#39;@angular/forms&#39;;
</code-example></div><p>Now enter the <code>@Component</code> decorator that specifies the <code>HeroDetailComponent</code> metadata:</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts (excerpt)</h4></header><code-example language="ts" format="">@Component({
  selector: &#39;hero-detail&#39;,
  templateUrl: &#39;./hero-detail.component.html&#39;
})
</code-example></div><p>Next, create an exported <code>HeroDetailComponent</code> class with a <code>FormControl</code>. 
<code>FormControl</code> is a directive that allows you to create and manage 
a <code>FormControl</code> instance directly.</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts (excerpt)</h4></header><code-example language="ts" format="">export class HeroDetailComponent1 {
  name = new FormControl();
}
</code-example></div><p>Here you are creating a <code>FormControl</code> called <code>name</code>. 
It will be bound in the template to an HTML <code>input</code> box for the hero name. </p>
<p>A <code>FormControl</code> constructor accepts three, optional arguments: 
the initial data value, an array of validators, and an array of async validators.</p>
<p>This simple control doesn&#39;t have data or validators.
In real apps, most form controls have both. </p>
<div class="l-sub-section"><p>This guide touches only briefly on <code>Validators</code>. For an in-depth look at them,
read the <a href="../cookbook/form-validation.html">Form Validation</a> cookbook.</p>
</div><div class="l-main-section"></div><a id="create-template"></a><h2 id="create-the-template">Create the template</h2>
<p>Now create the component&#39;s template, <code>src/app/hero-detail.component.html</code>, with the following markup.</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.html</h4></header><code-example language="html" format="">&lt;h2&gt;Hero Detail&lt;/h2&gt;
&lt;h3&gt;&lt;i&gt;Just a FormControl&lt;/i&gt;&lt;/h3&gt;
&lt;label class=&quot;center-block&quot;&gt;Name:
  &lt;input class=&quot;form-control&quot; [formControl]=&quot;name&quot;&gt;
&lt;/label&gt;
</code-example></div><p>To let Angular know that this is the input that you want to 
associate to the <code>name</code> <code>FormControl</code> in the class, 
you need <code>[formControl]=&quot;name&quot;</code> in the template on the <code>&lt;input&gt;</code>. </p>
<div class="l-sub-section"><p>Disregard the <code>form-control</code> <em>CSS</em> class. It belongs to the 
<a href="http://getbootstrap.com/" target="_blank" title="Bootstrap CSS">Bootstrap CSS library</a>,
not Angular.
It <em>styles</em> the form but in no way impacts the logic of the form.</p>
</div><a id="import"></a><h2 id="import-the-_reactiveformsmodule_">Import the <em>ReactiveFormsModule</em></h2>
<p>The HeroDetailComponent template uses <code>formControlName</code> 
directive from the <code>ReactiveFormsModule</code>.</p>
<p>In this sample, you declare the <code>HeroDetailComponent</code> in the <code>AppModule</code>.
Therefore, do the following three things in <code>app.module.ts</code>:</p>
<ol>
<li>Use a JavaScript <code>import</code> statement to access 
the <code>ReactiveFormsModule</code> and the <code>HeroDetailComponent</code>.</li>
<li>Add <code>ReactiveFormsModule</code> to the <code>AppModule</code>&#39;s <code>imports</code> list.</li>
<li>Add <code>HeroDetailComponent</code> to the declarations array.</li>
</ol>
<div class="code-example"><header><h4>src/app/app.module.ts (excerpt)</h4></header><code-example language="ts" format="">import { NgModule }            from &#39;@angular/core&#39;;
import { BrowserModule }       from &#39;@angular/platform-browser&#39;;
import { ReactiveFormsModule } from &#39;@angular/forms&#39;;  // &lt;-- #1 import module

import { AppComponent }        from &#39;./app.component&#39;;
import { HeroDetailComponent } from &#39;./hero-detail.component&#39;; // &lt;-- #1 import component

@NgModule({
  imports: [
    BrowserModule,
    ReactiveFormsModule // &lt;-- #2 add to Angular module imports
  ],
  declarations: [
    AppComponent,
    HeroDetailComponent, // &lt;-- #3 declare app component
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
</code-example></div><a id="update"></a><div class="l-main-section"></div><h2 id="display-the-_herodetailcomponent_">Display the <em>HeroDetailComponent</em></h2>
<p>Revise the <code>AppComponent</code> template so it displays the <code>HeroDetailComponent</code>.</p>
<div class="code-example"><header><h4>src/app/app.component.ts</h4></header><code-example language="ts" format="">import { Component } from &#39;@angular/core&#39;;

@Component({
  selector: &#39;my-app&#39;,
  template: `
  &lt;div class=&quot;container&quot;&gt;
    &lt;h1&gt;Reactive Forms&lt;/h1&gt;
    &lt;hero-detail&gt;&lt;/hero-detail&gt;
  &lt;/div&gt;`
})
export class AppComponent { }
</code-example></div><a id="essentials"></a><h3 id="essential-form-classes">Essential form classes</h3>
<p>It may be helpful to read a brief description of the core form classes.</p>
<ul>
<li><p><a href="../api/forms/index/AbstractControl-class.html" title="API Reference: AbstractControl"><em>AbstractControl</em></a>
is the abstract base class for the three concrete form control classes: 
<code>FormControl</code>, <code>FormGroup</code>, and <code>FormArray</code>.
It provides their common behaviors and properties, some of which are <em>observable</em>.</p>
</li>
<li><p><a href="../api/forms/index/FormControl-class.html" title="API Reference: FormControl"><em>FormControl</em></a> 
tracks the value and validity status of an <em>individual</em> form control.
It corresponds to an HTML form control such as an input box or selector.</p>
</li>
<li><p><a href="../api/forms/index/FormGroup-class.html" title="API Reference: FormGroup"><em>FormGroup</em></a>
tracks the value and validity state of a <em>group</em> of <code>AbstractControl</code> instances.
The group&#39;s properties include its child controls.
The top-level form in your component is a <code>FormGroup</code>.</p>
</li>
<li><p><a href="../api/forms/index/FormArray-class.html" title="API Reference: FormArray"><em>FormArray</em></a>
tracks the value and validity state of a numerically indexed <em>array</em> of <code>AbstractControl</code> instances.</p>
</li>
</ul>
<p>You&#39;ll learn more about these classes as you work through this guide.</p>
<h3 id="style-the-app">Style the app</h3>
<p>You used bootstrap CSS classes in the template HTML of both the <code>AppComponent</code> and the <code>HeroDetailComponent</code>.
Add the <code>bootstrap</code> <em>CSS stylesheet</em> to the head of <code>index.html</code>:</p>
<div class="code-example"><header><h4>index.html</h4></header><code-example language="html" format="">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css&quot;&gt;
</code-example></div><p>Now that everything is wired up, the browser should display something like this: </p>
<figure class="image-display"><img src="/resources/images/devguide/reactive-forms/just-formcontrol.png" width="400px" alt="Single FormControl"></figure><a id="formgroup"></a><h2 id="add-a-formgroup">Add a FormGroup</h2>
<p>Usually, if you have multiple <em>FormControls</em>, you&#39;ll want to register 
them within a parent <code>FormGroup</code>.
This is simple to do. To add a <code>FormGroup</code>, add it to the imports section 
of <code>hero-detail.component.ts</code>:</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts</h4></header><code-example language="ts" format="">import { Component }              from &#39;@angular/core&#39;;
import { FormControl, FormGroup } from &#39;@angular/forms&#39;;
</code-example></div><p>In the class, wrap the <code>FormControl</code> in a <code>FormGroup</code> called <code>heroForm</code> as follows:</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts</h4></header><code-example language="ts" format="">export class HeroDetailComponent2 {
  heroForm = new FormGroup ({
    name: new FormControl()
  });
}
</code-example></div><p>Now that you&#39;ve made changes in the class, they need to be reflected in the 
template. Update <code>hero-detail.component.html</code> by replacing it with the following.</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.html</h4></header><code-example language="html" format="">&lt;h2&gt;Hero Detail&lt;/h2&gt;
&lt;h3&gt;&lt;i&gt;FormControl in a FormGroup&lt;/i&gt;&lt;/h3&gt;
&lt;form [formGroup]=&quot;heroForm&quot; novalidate&gt;
  &lt;div class=&quot;form-group&quot;&gt;
    &lt;label class=&quot;center-block&quot;&gt;Name:
      &lt;input class=&quot;form-control&quot; formControlName=&quot;name&quot;&gt;
    &lt;/label&gt;
  &lt;/div&gt;
&lt;/form&gt;
</code-example></div><p>Notice that now the single input is in a <code>form</code> element. The <code>novalidate</code> 
attribute in the <code>&lt;form&gt;</code> element prevents the browser 
from attempting native HTML validations. </p>
<p><code>formGroup</code> is a reactive form directive that takes an existing 
<code>FormGroup</code> instance and associates it with an HTML element. 
In this case, it associates the <code>FormGroup</code> you saved as 
<code>heroForm</code> with the form element.</p>
<p>Because the class now has a <code>FormGroup</code>, you must update the template 
syntax for associating the input with the corresponding 
<code>FormControl</code> in the component class. 
Without a parent <code>FormGroup</code>, 
<code>[formControl]=&quot;name&quot;</code> worked earlier because that directive 
can stand alone, that is, it works without being in a <code>FormGroup</code>. 
With a parent <code>FormGroup</code>, the <code>name</code> input needs the syntax 
<code>formControlName=name</code> in order to be associated 
with the correct <code>FormControl</code> 
in the class. This syntax tells Angular to look for the parent 
<code>FormGroup</code>, in this case <code>heroForm</code>, and then <em>inside</em> that group 
to look for a <code>FormControl</code> called <code>name</code>.</p>
<div class="l-sub-section"><p>Disregard the <code>form-group</code> <em>CSS</em> class. It belongs to the 
<a href="http://getbootstrap.com/" target="_blank" title="Bootstrap CSS">Bootstrap CSS library</a>,
not Angular.
Like the <code>form-control</code> class, it <em>styles</em> the form 
but in no way impacts its logic.</p>
</div><p>The form looks great. But does it work? 
When the user enters a name, where does the value go? </p>
<a id="json"></a><h2 id="taking-a-look-at-the-form-model">Taking a look at the form model</h2>
<p>The value goes into the <strong><em>form model</em></strong> that backs the group&#39;s <code>FormControls</code>.
To see the form model, add the following line after the 
closing <code>form</code> tag in the <code>hero-detail.component.html</code>:</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.html</h4></header><code-example language="html" format="">&lt;p&gt;Form value: {{ heroForm.value | json }}&lt;/p&gt;
&lt;p&gt;Form status: {{ heroForm.status | json }}&lt;/p&gt;
</code-example></div><p>The <code>heroForm.value</code> returns the <em>form model</em>.
Piping it through the <code>JsonPipe</code> renders the model as JSON in the browser:</p>
<figure class="image-display"><img src="/resources/images/devguide/reactive-forms/json-output.png" width="400px" alt="JSON output"></figure><p>The initial <code>name</code> property value is the empty string. 
Type into the <em>name</em> input box and watch the keystokes appear in the JSON.</p>
<p>Great! You have the basics of a form. </p>
<p>In real life apps, forms get big fast. 
<code>FormBuilder</code> makes form development and maintenance easier.</p>
<div class="l-main-section"></div><a id="formbuilder"></a><h2 id="introduction-to-_formbuilder_">Introduction to <em>FormBuilder</em></h2>
<p>The <code>FormBuilder</code> class helps reduce repetition and 
clutter by handling details of control creation for you. </p>
<p>To use <code>FormBuilder</code>, you need to import it into <code>hero-detail.component.ts</code>:</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts (excerpt)</h4></header><code-example language="ts" format="">import { Component }              from &#39;@angular/core&#39;;
import { FormBuilder, FormGroup } from &#39;@angular/forms&#39;;
</code-example></div><p>Use it now to refactor the <code>HeroDetailComponent</code> into something that&#39;s a little easier to read and write,
by following this plan:</p>
<ul>
<li>Explicitly declare the type of the <code>heroForm</code> property to be <code>FormGroup</code>; you&#39;ll initialize it later.</li>
<li>Inject a <code>FormBuilder</code> into the constructor.</li>
<li>Add a new method that uses the <code>FormBuilder</code> to define the <code>heroForm</code>; call it <code>createForm</code>.</li>
<li>Call <code>createForm</code> in the constructor.</li>
</ul>
<p>The revised <code>HeroDetailComponent</code> looks like this:</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts (excerpt)</h4></header><code-example language="ts" format="">export class HeroDetailComponent3 {
  heroForm: FormGroup; // &lt;--- heroForm is of type FormGroup

  constructor(private fb: FormBuilder) { // &lt;--- inject FormBuilder
    this.createForm();
  }

  createForm() {
    this.heroForm = this.fb.group({
      name: &#39;&#39;, // &lt;--- the FormControl called &quot;name&quot;
    });
  }
}
</code-example></div><p><code>FormBuilder.group</code> is a factory method that creates a <code>FormGroup</code>. &nbsp;
<code>FormBuilder.group</code> takes an object whose keys and values are <code>FormControl</code> names and their definitions. 
In this example, the <code>name</code> control is defined by its initial data value, an empty string.</p>
<p>Defining a group of controls in a single object makes for a compact, readable style.
It beats writing an equivalent series of <code>new FormControl(...)</code> statements.</p>
<a id="validators"></a><h3 id="validators-required">Validators.required</h3>
<p>Though this guide doesn&#39;t go deeply into validations, here is one example that 
demonstrates the simplicity of using <code>Validators.required</code> in reactive forms. </p>
<p>First, import the <code>Validators</code> symbol.</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts (excerpt)</h4></header><code-example language="ts" format="">import { Component }                          from &#39;@angular/core&#39;;
import { FormBuilder, FormGroup, Validators } from &#39;@angular/forms&#39;;
</code-example></div><p>To make the <code>name</code> <code>FormControl</code> required, replace the <code>name</code> 
property in the <code>FormGroup</code> with an array. 
The first item is the initial value for <code>name</code>;
the second is the required validator, <code>Validators.required</code>.</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts (excerpt)</h4></header><code-example language="ts" format="">this.heroForm = this.fb.group({
  name: [&#39;&#39;, Validators.required ],
});
</code-example></div><div class="l-sub-section"><p>Reactive validators are simple, composable functions.
Configuring validation is harder in template-driven forms where you must wrap validators in a directive. </p>
</div><p>Update the diagnostic message at the bottom of the template to display the form&#39;s validity status.</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.html (excerpt)</h4></header><code-example language="html" format="">&lt;p&gt;Form value: {{ heroForm.value | json }}&lt;/p&gt;
&lt;p&gt;Form status: {{ heroForm.status | json }}&lt;/p&gt;
</code-example></div><p>The browser displays the following:</p>
<figure class="image-display"><img src="/resources/images/devguide/reactive-forms/validators-json-output.png" width="400px" alt="Single FormControl"></figure><p><code>Validators.required</code> is working. The status is <code>INVALID</code> because the input box has no value.
Type into the input box to see the status change from <code>INVALID</code> to <code>VALID</code>. </p>
<p>In a real app, you&#39;d replace the diagnosic message with a user-friendly experience.</p>
<p>Using <code>Validators.required</code> is optional for the rest of the guide. 
It remains in each of the following examples with the same configuration.</p>
<p>For more on validating Angular forms, see the
<a href="../cookbook/form-validation.html">Form Validation</a> guide. </p>
<h3 id="more-formcontrols">More FormControls</h3>
<p>A hero has more than a name. 
A hero has an address, a super power and sometimes a sidekick too. </p>
<p>The address has a state property. The user will select a state with a <code>&lt;select&gt;</code> box and you&#39;ll populate 
the <code>&lt;option&gt;</code> elements with states. So import <code>states</code> from <code>data-model.ts</code>.</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts (excerpt)</h4></header><code-example language="ts" format="">import { Component }                          from &#39;@angular/core&#39;;
import { FormBuilder, FormGroup, Validators } from &#39;@angular/forms&#39;;

import { states } from &#39;./data-model&#39;;
</code-example></div><p>Declare the <code>states</code> property and add some address <code>FormControls</code> to the <code>heroForm</code> as follows. </p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts (excerpt)</h4></header><code-example language="ts" format="">export class HeroDetailComponent4 {
  heroForm: FormGroup;
  states = states;

  constructor(private fb: FormBuilder) {
    this.createForm();
  }

  createForm() {
    this.heroForm = this.fb.group({
      name: [&#39;&#39;, Validators.required ],
      street: &#39;&#39;,
      city: &#39;&#39;,
      state: &#39;&#39;,
      zip: &#39;&#39;,
      power: &#39;&#39;,
      sidekick: &#39;&#39;
    });
  }
}
</code-example></div><p>Then add corresponding markup in <code>hero-detail.component.html</code> 
within the <code>form</code> element.</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.html</h4></header><code-example language="html" format="">&lt;h2&gt;Hero Detail&lt;/h2&gt;
&lt;h3&gt;&lt;i&gt;A FormGroup with multiple FormControls&lt;/i&gt;&lt;/h3&gt;
&lt;form [formGroup]=&quot;heroForm&quot; novalidate&gt;
  &lt;div class=&quot;form-group&quot;&gt;
    &lt;label class=&quot;center-block&quot;&gt;Name:
      &lt;input class=&quot;form-control&quot; formControlName=&quot;name&quot;&gt;
    &lt;/label&gt;
  &lt;/div&gt;
  &lt;div class=&quot;form-group&quot;&gt;
    &lt;label class=&quot;center-block&quot;&gt;Street:
      &lt;input class=&quot;form-control&quot; formControlName=&quot;street&quot;&gt;
    &lt;/label&gt;
  &lt;/div&gt;
  &lt;div class=&quot;form-group&quot;&gt;
    &lt;label class=&quot;center-block&quot;&gt;City:
      &lt;input class=&quot;form-control&quot; formControlName=&quot;city&quot;&gt;
    &lt;/label&gt;
  &lt;/div&gt;
  &lt;div class=&quot;form-group&quot;&gt;
    &lt;label class=&quot;center-block&quot;&gt;State:
      &lt;select class=&quot;form-control&quot; formControlName=&quot;state&quot;&gt;
          &lt;option *ngFor=&quot;let state of states&quot; [value]=&quot;state&quot;&gt;{{state}}&lt;/option&gt;
      &lt;/select&gt;
    &lt;/label&gt;
  &lt;/div&gt;
  &lt;div class=&quot;form-group&quot;&gt;
    &lt;label class=&quot;center-block&quot;&gt;Zip Code:
      &lt;input class=&quot;form-control&quot; formControlName=&quot;zip&quot;&gt;
    &lt;/label&gt;
  &lt;/div&gt;
  &lt;div class=&quot;form-group radio&quot;&gt;
    &lt;h4&gt;Super power:&lt;/h4&gt;
    &lt;label class=&quot;center-block&quot;&gt;&lt;input type=&quot;radio&quot; formControlName=&quot;power&quot; value=&quot;flight&quot;&gt;Flight&lt;/label&gt;
    &lt;label class=&quot;center-block&quot;&gt;&lt;input type=&quot;radio&quot; formControlName=&quot;power&quot; value=&quot;x-ray vision&quot;&gt;X-ray vision&lt;/label&gt;
    &lt;label class=&quot;center-block&quot;&gt;&lt;input type=&quot;radio&quot; formControlName=&quot;power&quot; value=&quot;strength&quot;&gt;Strength&lt;/label&gt;
  &lt;/div&gt;
  &lt;div class=&quot;checkbox&quot;&gt;
    &lt;label class=&quot;center-block&quot;&gt;
      &lt;input type=&quot;checkbox&quot; formControlName=&quot;sidekick&quot;&gt;I have a sidekick.
    &lt;/label&gt;
  &lt;/div&gt;
&lt;/form&gt;


&lt;p&gt;Form value: {{ heroForm.value | json }}&lt;/p&gt;
</code-example></div><div class="alert is-helpful"><p><em>Reminder</em>: Ignore the many mentions of <code>form-group</code>, 
<code>form-control</code>, <code>center-block</code>, and <code>checkbox</code> in this markup.
Those are <em>bootstrap</em> CSS classes that Angular itself ignores.
Pay attention to the <code>formGroupName</code> and <code>formControlName</code> attributes.
They are the Angular directives that bind the HTML controls to the 
Angular <code>FormGroup</code> and <code>FormControl</code> properties in the component class.</p>
</div><p>The revised template includes more text inputs, a select box for the <code>state</code>, radio buttons for the <code>power</code>, 
and a checkbox for the <code>sidekick</code>. </p>
<p>You must bind the option&#39;s value property with <code>[value]=&quot;state&quot;</code>. 
If you do not bind the value, the select shows the first option form the data model.</p>
<p>The component <em>class</em> defines control properties without regard for their representation in the template.
You define the <code>state</code>, <code>power</code>, and <code>sidekick</code> controls the same way you defined the <code>name</code> control.
You tie these controls to the template HTML elements in the same way, 
specifiying the <code>FormControl</code> name with the <code>formControlName</code> directive. </p>
<p>See the API reference for more information about 
<a href="../api/forms/index/RadioControlValueAccessor-directive.html" title="API: RadioControlValueAccessor">radio buttons</a>, 
<a href="../api/forms/index/SelectControlValueAccessor-directive.html" title="API: SelectControlValueAccessor">selects</a>, and
<a href="../api/forms/index/CheckboxControlValueAccessor-directive.html" title="API: CheckboxControlValueAccessor">checkboxes</a>.</p>
<div class="l-main-section"></div><a id="grouping"></a><h3 id="nested-formgroups">Nested FormGroups</h3>
<p>This form is getting big and unwieldy. You can group some of the related <code>FormControls</code> 
into a nested <code>FormGroup</code>. The <code>street</code>, <code>city</code>, <code>state</code>, and <code>zip</code> are properties 
that would make a good <em>address</em> <code>FormGroup</code>.
Nesting groups and controls in this way allows you to 
mirror the hierarchical structure of the data model 
and helps track validation and state for related sets of controls. </p>
<p>You used the <code>FormBuilder</code> to create one <code>FormGroup</code> in this component called <code>heroForm</code>.
Let that be the parent <code>FormGroup</code>.
Use <code>FormBuilder</code> again to create a child <code>FormGroup</code> that encapsulates the address controls;
assign the result to a new <code>address</code> property of the parent <code>FormGroup</code>.</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts (excerpt)</h4></header><code-example language="ts" format="">export class HeroDetailComponent5 {
  heroForm: FormGroup;
  states = states;

  constructor(private fb: FormBuilder) {
    this.createForm();
  }

  createForm() {
    this.heroForm = this.fb.group({ // &lt;-- the parent FormGroup
      name: [&#39;&#39;, Validators.required ],
      address: this.fb.group({ // &lt;-- the child FormGroup
        street: &#39;&#39;,
        city: &#39;&#39;,
        state: &#39;&#39;,
        zip: &#39;&#39;
      }),
      power: &#39;&#39;,
      sidekick: &#39;&#39;
    });
  }
}
</code-example></div><p>You’ve changed the structure of the form controls in the component class; 
you must make corresponding adjustments to the component template.</p>
<p>In <code>hero-detail.component.html</code>, wrap the address-related <code>FormControls</code> in a <code>div</code>.
Add a <code>formGroupName</code> directive to the <code>div</code> and bind it to <code>&quot;address&quot;</code>.
That&#39;s the property of the <em>address</em> child <code>FormGroup</code> within the parent <code>FormGroup</code> called <code>heroForm</code>.</p>
<p>To make this change visually obvious, slip in an <code>&lt;h4&gt;</code> header near the top with the text, <em>Secret Lair</em>. 
The new <em>address</em> HTML looks like this:</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.html (excerpt)</h4></header><code-example language="html" format="">&lt;div formGroupName=&quot;address&quot; class=&quot;well well-lg&quot;&gt;
  &lt;h4&gt;Secret Lair&lt;/h4&gt;
  &lt;div class=&quot;form-group&quot;&gt;
    &lt;label class=&quot;center-block&quot;&gt;Street:
      &lt;input class=&quot;form-control&quot; formControlName=&quot;street&quot;&gt;
    &lt;/label&gt;
  &lt;/div&gt;
  &lt;div class=&quot;form-group&quot;&gt;
    &lt;label class=&quot;center-block&quot;&gt;City:
      &lt;input class=&quot;form-control&quot; formControlName=&quot;city&quot;&gt;
    &lt;/label&gt;
  &lt;/div&gt;
  &lt;div class=&quot;form-group&quot;&gt;
    &lt;label class=&quot;center-block&quot;&gt;State:
      &lt;select class=&quot;form-control&quot; formControlName=&quot;state&quot;&gt;
        &lt;option *ngFor=&quot;let state of states&quot; [value]=&quot;state&quot;&gt;{{state}}&lt;/option&gt;
      &lt;/select&gt;
    &lt;/label&gt;
  &lt;/div&gt;
  &lt;div class=&quot;form-group&quot;&gt;
    &lt;label class=&quot;center-block&quot;&gt;Zip Code:
      &lt;input class=&quot;form-control&quot; formControlName=&quot;zip&quot;&gt;
    &lt;/label&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code-example></div><p>After these changes, the JSON output in the browser shows the revised <em>form model</em>
with the nested address <code>FormGroup</code>: </p>
<figure class="image-display"><img src="/resources/images/devguide/reactive-forms/address-group.png" width="400px" alt="JSON output"></figure><p>Great! You’ve made a group and you can see that the template 
and the form model are talking to one another.</p>
<div class="l-main-section"></div><a id="properties"></a><h2 id="inspect-_formcontrol_-properties">Inspect <em>FormControl</em> Properties</h2>
<p>At the moment, you&#39;re dumping the entire form model onto the page.
Sometimes you&#39;re interested only in the state of one particular <code>FormControl</code>.</p>
<p>You can inspect an individual <code>FormControl</code> within a form by extracting it with the <code>.get()</code> method.
You can do this <em>within</em> the component class or display it on the 
page by adding the following to the template, 
immediately after the <code>{{form.value | json}}</code> interpolation as follows: </p>
<div class="code-example"><header><h4>src/app/hero-detail.component.html</h4></header><code-example language="html" format="">&lt;p&gt;Name value: {{ heroForm.get(&#39;name&#39;).value }}&lt;/p&gt;
</code-example></div><p>To get the state of a <code>FormControl</code> that’s inside a <code>FormGroup</code>, use dot notation to path to the control.</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.html</h4></header><code-example language="html" format="">&lt;p&gt;Street value: {{ heroForm.get(&#39;address.street&#39;).value}}&lt;/p&gt;
</code-example></div><p>You can use this technique to display <em>any</em> property of a <code>FormControl</code> 
such as one of the following:</p>
<style>td, th {vertical-align: top}</style><table width="100%"><col width="10%"><col width="90%"><tr><th>Property</th><th>Description</th></tr><tr><td><code>myControl.value</code></td><td><p>the value of a <code>FormControl</code>.</p>
</td></tr><tr><td><code>myControl.status</code></td><td><p>the validity of a <code>FormControl</code>. Possible values: <code>VALID</code>, 
 <code>INVALID</code>, <code>PENDING</code>, or <code>DISABLED</code>.</p>
</td></tr><tr><td><code>myControl.pristine</code></td><td><p><code>true</code> if the user has <em>not</em> changed the value in the UI.
Its opposite is <code>myControl.dirty</code>.</p>
</td></tr><tr><td><code>myControl.untouched</code></td><td><p><code>true</code> if the control user has not yet entered the HTML control
 and triggered its blur event. Its opposite is <code>myControl.touched</code>.</p>
</td></tr></table><p>Learn about other <code>FormControl</code> properties in the 
<a href="../api/forms/index/AbstractControl-class.html"><em>AbstractControl</em></a> API reference.</p>
<p>One common reason for inspecting <code>FormControl</code> properties is to 
make sure the user entered valid values. 
Read more about validating Angular forms in the 
<a href="../cookbook/form-validation.html">Form Validation</a> guide. </p>
<div class="l-main-section"></div><a id="data-model-form-model"></a><h2 id="the-_data-model_-and-the-_form-model_">The <em>data model</em> and the <em>form model</em></h2>
<p>At the moment, the form is displaying empty values.
The <code>HeroDetailComponent</code> should display values of a hero,
possibly a hero retrieved from a remote server.</p>
<p>In this app, the <code>HeroDetailComponent</code> gets its hero from a parent <code>HeroListComponent</code></p>
<p>The <code>hero</code> from the server is the <strong><em>data model</em></strong>.
The <code>FormControl</code> structure is the <strong><em>form model</em></strong>.</p>
<p>The component must copy the hero values in the <em>data model</em> into the <em>form model</em>.
There are two important implications:</p>
<ol>
<li><p>The developer must understand how the properties of the <em>data model</em> 
map to the properties of the <em>form model</em>.</p>
</li>
<li><p>User changes flow from the DOM elements to the <em>form model</em>, not to the <em>data model</em>.
The form controls never update the <em>data model</em>.</p>
</li>
</ol>
<p>The <em>form</em> and <em>data</em> model structures need not match exactly.
You often present a subset of the <em>data model</em> on a particular screen.
But it makes things easier if the shape of the <em>form model</em> is close to the shape of the <em>data model</em>.</p>
<p>In this <code>HeroDetailComponent</code>, the two models are quite close.</p>
<p>Recall the definition of <code>Hero</code> in <code>data-model.ts</code>:</p>
<div class="code-example"><header><h4>src/app/data-model.ts (classes)</h4></header><code-example language="ts" format="">export class Hero {
  id = 0;
  name = &#39;&#39;;
  addresses: Address[];
}

export class Address {
  street = &#39;&#39;;
  city   = &#39;&#39;;
  state  = &#39;&#39;;
  zip    = &#39;&#39;;
}
</code-example></div><p>Here, again, is the component&#39;s <code>FormGroup</code> definition.</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts (excerpt)</h4></header><code-example language="ts" format="">this.heroForm = this.fb.group({
  name: [&#39;&#39;, Validators.required ],
  address: this.fb.group({
    street: &#39;&#39;,
    city: &#39;&#39;,
    state: &#39;&#39;,
    zip: &#39;&#39;
  }),
  power: &#39;&#39;,
  sidekick: &#39;&#39;
});
</code-example></div><p>There are two significant differences between these models:</p>
<ol>
<li><p>The <code>Hero</code> has an <code>id</code>. The form model does not because you generally don&#39;t show primary keys to users.</p>
</li>
<li><p>The <code>Hero</code> has an array of addresses. This form model presents only one address,
a choice <a href="#form-array" title="Form arrays">revisited below</a>.</p>
</li>
</ol>
<p>Nonetheless, the two models are pretty close in shape and you&#39;ll see in a moment how this alignment facilitates copying the <em>data model</em> properties
to the <em>form model</em> with the <code>patchValue</code> and <code>setValue</code> methods.</p>
<p>Take a moment to refactor the <em>address</em> <code>FormGroup</code> definition for brevity and clarity as follows:</p>
<div class="code-example"><code-example language="ts" format="">this.heroForm = this.fb.group({
  name: [&#39;&#39;, Validators.required ],
  address: this.fb.group(new Address()), // &lt;-- a FormGroup with a new address
  power: &#39;&#39;,
  sidekick: &#39;&#39;
});
</code-example></div><p>Also be sure to update the import from <code>data-model</code> so you can reference the <code>Hero</code> and <code>Address</code> classes:</p>
<div class="code-example"><code-example language="ts" format="">import { Address, Hero, states } from &#39;./data-model&#39;;
</code-example></div><div class="l-main-section"></div><a id="set-data"></a><h2 id="populate-the-form-model-with-_setvalue_-and-_patchvalue_">Populate the form model with <em>setValue</em> and <em>patchValue</em></h2>
<p>Previously you created a control and initialized its value at the same time. 
You can also initialize or reset the values <em>later</em> with the 
<code>setValue</code> and <code>patchValue</code> methods.</p>
<h3 id="_setvalue_"><em>setValue</em></h3>
<p>With <strong><code>setValue</code></strong>, you assign <em>every</em> form control value <em>at once</em>
by passing in a data object whose properties exactly match the <em>form model</em> behind the <code>FormGroup</code>.</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts (excerpt)</h4></header><code-example language="ts" format="">    this.heroForm.setValue({
      name:    this.hero.name,
      address: this.hero.addresses[0] || new Address()
    });
</code-example></div><p>The <code>setValue</code> method checks the data object thoroughly before assigning any form control values.</p>
<p>It will not accept a data object that doesn&#39;t match the FormGroup structure or is 
missing values for any control in the group. This way, it can return helpful 
error messages if you have a typo or if you&#39;ve nested controls incorrectly. 
<code>patchValue</code> will fail silently.</p>
<p>On the other hand,<code>setValue</code> will catch 
the error and report it clearly. </p>
<p>Notice that you can <em>almost</em> use the entire <code>hero</code> as the argument to <code>setValue</code>
because its shape is similar to the component&#39;s <code>FormGroup</code> structure.</p>
<p>You can only show the hero&#39;s first address and you must account for the possibility that the <code>hero</code> has no addresses at all.
This explains the conditional setting of the <code>address</code> property in the data object argument:</p>
<div class="code-example"><code-example language="ts" format="">address: this.hero.addresses[0] || new Address()
</code-example></div><h3 id="_patchvalue_"><em>patchValue</em></h3>
<p>With <strong><code>patchValue</code></strong>, you can assign values to specific controls in a <code>FormGroup</code>
by supplying an object of key/value pairs for just the controls of interest. </p>
<p>This example sets only the form&#39;s <code>name</code> control.</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts (excerpt)</h4></header><code-example language="ts" format="">this.heroForm.patchValue({
  name: this.hero.name
});
</code-example></div><p>With <strong><code>patchValue</code></strong> you have more flexibility to cope with wildly divergent data and form models.
But unlike <code>setValue</code>,  <code>patchValue</code> cannot check for missing control 
values and does not throw helpful errors.</p>
<h3 id="when-to-set-form-model-values-_ngonchanges_-">When to set form model values (<em>ngOnChanges</em>)</h3>
<p>Now you know <em>how</em> to set the <em>form model</em> values. But <em>when</em> do you set them?
The answer depends upon when the component gets the <em>data model</em> values.</p>
<p>The <code>HeroDetailComponent</code> in this reactive forms sample is nested within a <em>master/detail</em> <code>HeroListComponent</code> (<a href="#hero-list">discussed below</a>).
The <code>HeroListComponent</code> displays hero names to the user.
When the user clicks on a hero, the list component passes the selected hero into the <code>HeroDetailComponent</code>
by binding to its <code>hero</code> input property.</p>
<div class="code-example"><header><h4>hero-list.component.html (simplified)</h4></header><code-example language="html" format="">&lt;nav&gt;
  &lt;a *ngFor=&quot;let hero of heroes | async&quot; (click)=&quot;select(hero)&quot;&gt;{{hero.name}}&lt;/a&gt;
&lt;/nav&gt;

&lt;div *ngIf=&quot;selectedHero&quot;&gt;
  &lt;hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/hero-detail&gt;
&lt;/div&gt;
</code-example></div><p>In this approach, the value of <code>hero</code> in the <code>HeroDetailComponent</code> changes 
every time the user selects a new hero.
You should call  <em>setValue</em> in the <a href="lifecyle-hooks.html#onchanges">ngOnChanges</a>
hook, which Angular calls whenever the input <code>hero</code> property changes
as the following steps demonstrate.</p>
<p>First, import the <code>OnChanges</code> and <code>Input</code> symbols in <code>hero-detail.component.ts</code>.</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts (core imports)</h4></header><code-example language="ts" format="">import { Component, Input, OnChanges }             from &#39;@angular/core&#39;;
</code-example></div><p>Add the <code>hero</code> input property.</p>
<div class="code-example"><code-example language="ts" format="">@Input() hero: Hero;
</code-example></div><p>Add the <code>ngOnChanges</code> method to the class as follows:</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts (ngOnchanges)</h4></header><code-example language="ts" format="">  ngOnChanges()
    this.heroForm.setValue({
      name:    this.hero.name,
      address: this.hero.addresses[0] || new Address()
    });
  }
</code-example></div><h3 id="_reset_-the-form-flags"><em>reset</em> the form flags</h3>
<p>You should  reset the form when the hero changes so that 
control values from the previous hero are cleared and 
status flags are restored to the <em>pristine</em> state.
You could call <code>reset</code> at the top of <code>ngOnChanges</code> like this.</p>
<div class="code-example"><code-example language="ts" format="">this.heroForm.reset();
</code-example></div><p>The <code>reset</code> method has an optional <code>state</code> value so you can reset the flags <em>and</em> the control values at the same. 
Internally, <code>reset</code> passes the argument to <code>setValue</code>. 
A little refactoring and <code>ngOnChanges</code> becomes this:</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts (ngOnchanges - revised)</h4></header><code-example language="ts" format="">ngOnChanges() {
  this.heroForm.reset({
    name: this.hero.name,
    address: this.hero.addresses[0] || new Address()
  });
}
</code-example></div><a id="hero-list"></a><h3 id="create-the-_herolistcomponent_-and-_heroservice_">Create the <em>HeroListComponent</em> and <em>HeroService</em></h3>
<p>The <code>HeroDetailComponent</code> is a nested sub-component of the <code>HeroListComponent</code> in a <em>master/detail</em> view.
Together they look a bit like this:</p>
<figure class="image-display"><img src="/resources/images/devguide/reactive-forms/hero-list.png" width="420px" alt="HeroListComponent"></figure><p>The <code>HeroListComponent</code> uses an injected <code>HeroService</code> to retrieve heroes from the server
and then presents those heroes to the user as a series of buttons.
The <code>HeroService</code> emulates an HTTP service. 
It returns an <code>Observable</code> of heroes that resolves after a short delay, 
both to simulate network latency and to indicate visually 
the necessarily asynchronous nature of the application.</p>
<p>When the user clicks on a hero,
the component sets its <code>selectedHero</code> property which
is bound to the <code>hero</code> input property of the <code>HeroDetailComponent</code>.
The <code>HeroDetailComponent</code> detects the changed hero and re-sets its form
with that hero&#39;s data values.</p>
<p>A &quot;Refresh&quot; button clears the hero list and the current selected hero before refetching the heroes.</p>
<p>The remaining <code>HeroListComponent</code> and <code>HeroService</code> implementation details are not relevant to understanding reactive forms.
The techniques involved are covered elsewhere in the documentation, including the <em>Tour of Heroes</em>
<a href="../tutorial/toh-pt3.html" title="ToH: Multiple Components">here</a> and <a href="../tutorial/toh-pt4.html" title="ToH: Services">here</a>.</p>
<p>If you&#39;re coding along with the steps in this reactive forms tutorial, 
create the pertinent files based on the 
<a href="#source-code" title="Reactive Forms source code">source code displayed below</a>. 
Notice that <code>hero-list.component.ts</code> imports <code>Observable</code> and <code>finally</code> while <code>hero.service.ts</code> imports <code>Observable</code>, <code>of</code>,
and <code>delay</code> from <code>rxjs</code>. 
Then return here to learn about <em>form array</em> properties.</p>
<div class="l-main-section"></div><a id="form-array"></a><h2 id="use-_formarray_-to-present-an-array-of-_formgroups_">Use <em>FormArray</em> to present an array of <em>FormGroups</em></h2>
<p>So far, you&#39;ve seen <code>FormControls</code> and <code>FormGroups</code>.
A <code>FormGroup</code> is a named object whose property values are <code>FormControls</code> and other <code>FormGroups</code>.</p>
<p>Sometimes you need to present an arbitrary number of controls or groups.
For example, a hero may have zero, one, or any number of addresses.</p>
<p>The <code>Hero.addresses</code> property is an array of <code>Address</code> instances.
An <em>address</em> <code>FormGroup</code> can display one <code>Address</code>.
An Angular <code>FormArray</code> can display an array of <em>address</em> <code>FormGroups</code>.</p>
<p>To get access to the <code>FormArray</code> class, import it into <code>hero-detail.component.ts</code>:</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts (excerpt)</h4></header><code-example language="ts" format="">import { Component, Input, OnChanges }                   from &#39;@angular/core&#39;;
import { FormArray, FormBuilder, FormGroup, Validators } from &#39;@angular/forms&#39;;

import { Address, Hero, states } from &#39;./data-model&#39;;
</code-example></div><p>To <em>work</em> with a <code>FormArray</code> you do the following:</p>
<ol>
<li>Define the items (<code>FormControls</code> or <code>FormGroups</code>) in the array.</li>
<li>Initialize the array with items created from data in the <em>data model</em>.</li>
<li>Add and remove items as the user requires.</li>
</ol>
<p>In this guide, you define a <code>FormArray</code> for <code>Hero.addresses</code> and
let the user add or modify addresses (removing addresses is your homework).</p>
<p>You’ll need to redefine the form model in the <code>HeroDetailComponent</code> constructor,
which currently only displays the first hero address in an <em>address</em> <code>FormGroup</code>. </p>
<div class="code-example"><code-example language="ts" format="">this.heroForm = this.fb.group({
  name: [&#39;&#39;, Validators.required ],
  address: this.fb.group(new Address()), // &lt;-- a FormGroup with a new address
  power: &#39;&#39;,
  sidekick: &#39;&#39;
});
</code-example></div><h3 id="from-_address_-to-_secret-lairs_">From <em>address</em> to <em>secret lairs</em></h3>
<p>From the user&#39;s point of view, heroes don&#39;t have <em>addresses</em>.
<em>Addresses</em> are for mere mortals. Heroes have <em>secret lairs</em>!
Replace the <em>address</em> <code>FormGroup</code> definition with a <em>secretLairs</em> <code>FormArray</code> definition:</p>
<div class="code-example"><code-example language="ts" format="">this.heroForm = this.fb.group({
  name: [&#39;&#39;, Validators.required ],
  secretLairs: this.fb.array([]), // &lt;-- secretLairs as an empty FormArray
  power: &#39;&#39;,
  sidekick: &#39;&#39;
});
</code-example></div><div class="alert is-helpful"><p>Changing the form control name from <code>address</code> to <code>secretLairs</code> drives home an important point:
the <em>form model</em> doesn&#39;t have to match the <em>data model</em>.</p>
<p>Obviously there has to be a relationship between the two. 
But it can be anything that makes sense within the application domain.</p>
<p><em>Presentation</em> requirements often differ from <em>data</em> requirements.
The reactive forms approach both emphasizes and facilitates this distinction.</p>
</div><h3 id="initialize-the-secretlairs-_formarray_">Initialize the &quot;secretLairs&quot; <em>FormArray</em></h3>
<p>The default form displays a nameless hero with no addresses.</p>
<p>You need a method to populate (or repopulate) the <em>secretLairs</em> with actual hero addresses whenever
the parent <code>HeroListComponent</code> sets the <code>HeroListComponent.hero</code> input property to a new <code>Hero</code>.</p>
<p>The following <code>setAddresses</code> method replaces the <em>secretLairs</em> <code>FormArray</code> with a new <code>FormArray</code>,
initialized by an array of hero address <code>FormGroups</code>.</p>
<div class="code-example"><code-example language="ts" format="">setAddresses(addresses: Address[]) {
  const addressFGs = addresses.map(address =&gt; this.fb.group(address));
  const addressFormArray = this.fb.array(addressFGs);
  this.heroForm.setControl(&#39;secretLairs&#39;, addressFormArray);
}
</code-example></div><p>Notice that you replace the previous <code>FormArray</code> with the <strong><code>FormGroup.setControl</code> method</strong>, not with <code>setValue</code>.
You&#39;re replacing a <em>control</em>, not the <em>value</em> of a control.</p>
<p>Notice also that the <em>secretLairs</em> <code>FormArray</code> contains <strong><code>FormGroups</code></strong>, not <code>Addresses</code>.</p>
<h3 id="get-the-_formarray_">Get the <em>FormArray</em></h3>
<p>The <code>HeroDetailComponent</code> should be able to display, add, and remove items from the <em>secretLairs</em> <code>FormArray</code>.</p>
<p>Use the <code>FormGroup.get</code> method to acquire a reference to that <code>FormArray</code>.
Wrap the expression in a <code>secretLairs</code> convenience property for clarity and re-use.</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts (secretLayers property)</h4></header><code-example language="ts" format="">get secretLairs(): FormArray {
  return this.heroForm.get(&#39;secretLairs&#39;) as FormArray;
};
</code-example></div><h3 id="display-the-_formarray_">Display the <em>FormArray</em></h3>
<p>The current HTML template displays a single <em>address</em> <code>FormGroup</code>.
Revise it to display zero, one, or more of the hero&#39;s <em>address</em> <code>FormGroups</code>.</p>
<p>This is mostly a matter of wrapping the previous template HTML for an address in a <code>&lt;div&gt;</code> and 
repeating that <code>&lt;div&gt;</code> with <code>*ngFor</code>.</p>
<p>The trick lies in knowing how to write the <code>*ngFor</code>. There are three key points:</p>
<ol>
<li><p>Add another wrapping <code>&lt;div&gt;</code>, around the <code>&lt;div&gt;</code> with <code>*ngFor</code>, and 
set its <code>formArrayName</code> directive to <code>&quot;secretLairs&quot;</code>.
This step establishes the <em>secretLairs</em> <code>FormArray</code> as the context for form controls in the inner, repeated HTML template. </p>
</li>
<li><p>The source of the repeated items is the <code>FormArray.controls</code>, not the <code>FormArray</code> itself. 
Each control is an <em>address</em> <code>FormGroup</code>, exactly what the previous (now repeated) template HTML expected.</p>
</li>
<li><p>Each repeated <code>FormGroup</code> needs a unique <code>formGroupName</code> which must be the index of the <code>FormGroup</code> in the <code>FormArray</code>.
You&#39;ll re-use that index to compose a unique label for each address.</p>
</li>
</ol>
<p>Here&#39;s the skeleton for the <em>secret lairs</em> section of the HTML template:</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.html (*ngFor)</h4></header><code-example language="html" format="">&lt;div formArrayName=&quot;secretLairs&quot; class=&quot;well well-lg&quot;&gt;
  &lt;div *ngFor=&quot;let address of secretLairs.controls; let i=index&quot; [formGroupName]=&quot;i&quot; &gt;
    &lt;!-- The repeated address template --&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code-example></div><p>Here&#39;s the complete template for the <em>secret lairs</em> section:</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.html (excerpt)</h4></header><code-example language="html" format="linenums">    &lt;div formArrayName=&quot;secretLairs&quot; class=&quot;well well-lg&quot;&gt;
      &lt;div *ngFor=&quot;let address of secretLairs.controls; let i=index&quot; [formGroupName]=&quot;i&quot; &gt;
        &lt;!-- The repeated address template --&gt;
        &lt;h4&gt;Address #{{i + 1}}&lt;/h4&gt;
        &lt;div style=&quot;margin-left: 1em;&quot;&gt;
          &lt;div class=&quot;form-group&quot;&gt;
            &lt;label class=&quot;center-block&quot;&gt;Street:
              &lt;input class=&quot;form-control&quot; formControlName=&quot;street&quot;&gt;
            &lt;/label&gt;
          &lt;/div&gt;
          &lt;div class=&quot;form-group&quot;&gt;
            &lt;label class=&quot;center-block&quot;&gt;City:
              &lt;input class=&quot;form-control&quot; formControlName=&quot;city&quot;&gt;
            &lt;/label&gt;
          &lt;/div&gt;
          &lt;div class=&quot;form-group&quot;&gt;
            &lt;label class=&quot;center-block&quot;&gt;State:
              &lt;select class=&quot;form-control&quot; formControlName=&quot;state&quot;&gt;
                &lt;option *ngFor=&quot;let state of states&quot; [value]=&quot;state&quot;&gt;{{state}}&lt;/option&gt;
              &lt;/select&gt;
            &lt;/label&gt;
          &lt;/div&gt;
          &lt;div class=&quot;form-group&quot;&gt;
            &lt;label class=&quot;center-block&quot;&gt;Zip Code:
              &lt;input class=&quot;form-control&quot; formControlName=&quot;zip&quot;&gt;
            &lt;/label&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;br&gt;
        &lt;!-- End of the repeated address template --&gt;
      &lt;/div&gt;
    &lt;/div&gt;
</code-example></div><h3 id="add-a-new-lair-to-the-_formarray_">Add a new lair to the <em>FormArray</em></h3>
<p>Add an <code>addLair</code> method that gets the <em>secretLairs</em> <code>FormArray</code> and appends a new <em>address</em> <code>FormGroup</code> to it. </p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts (addLair method)</h4></header><code-example language="ts" format="">addLair() {
  this.secretLairs.push(this.fb.group(new Address()));
}
</code-example></div><p>Place a button on the form so the user can add a new <em>secret lair</em> and wire it to the component&#39;s <code>addLair</code> method.</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.html (addLair button)</h4></header><code-example language="html" format="">&lt;button (click)=&quot;addLair()&quot; type=&quot;button&quot;&gt;Add a Secret Lair&lt;/button&gt;
</code-example></div><div class="alert is-important"><p>Be sure to <strong>add the <code>type=&quot;button&quot;</code> attribute</strong>. 
In fact, you should always specify a button&#39;s <code>type</code>.
Without an explict type, the button type defaults to &quot;submit&quot;.
When you later add a <em>form submit</em> action, every &quot;submit&quot; button triggers the submit action which
might do something like save the current changes.
You do not want to save changes when the user clicks the <em>Add a Secret Lair</em> button.</p>
</div><h3 id="try-it-">Try it!</h3>
<p>Back in the browser, select the hero named &quot;Magneta&quot;.
&quot;Magneta&quot; doesn&#39;t have an address, as you can see in the diagnostic JSON at the bottom of the form.</p>
<figure class="image-display"><img src="/resources/images/devguide/reactive-forms/addresses-array.png" width="400px" alt="JSON output of addresses array"></figure><p>Click the &quot;<em>Add a Secret Lair</em>&quot; button. 
A new address section appears. Well done!</p>
<h3 id="remove-a-lair">Remove a lair</h3>
<p>This example can <em>add</em> addresses but it can&#39;t <em>remove</em> them.
For extra credit, write a <code>removeLair</code> method and wire it to a button on the repeating address HTML.</p>
<div class="l-main-section"></div><a id="observe-control"></a><h2 id="observe-control-changes">Observe control changes</h2>
<p>Angular calls <code>ngOnChanges</code> when the user picks a hero in the parent <code>HeroListComponent</code>.
Picking a hero changes the <code>HeroDetailComponent.hero</code> input property.</p>
<p>Angular does <em>not</em> call <code>ngOnChanges</code> when the user modifies the hero&#39;s <em>name</em> or <em>secret lairs</em>.
Fortunately, you can learn about such changes by subscribing to one of the form control properties 
that raises a change event.</p>
<p>These are properties, such as <code>valueChanges</code>, that return an RxJS <code>Observable</code>.
You don&#39;t need to know much about RxJS <code>Observable</code> to monitor form control values.</p>
<p>Add the following method to log changes to the value of the <em>name</em> <code>FormControl</code>.</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts (logNameChange)</h4></header><code-example language="ts" format="">nameChangeLog: string[] = [];
logNameChange() {
  const nameControl = this.heroForm.get(&#39;name&#39;);
  nameControl.valueChanges.forEach(
    (value: string) =&gt; this.nameChangeLog.push(value)
  );
}
</code-example></div><p>Call it in the constructor, after creating the form.</p>
<div class="code-example"><code-example language="ts" format="">constructor(private fb: FormBuilder) {
  this.createForm();
  this.logNameChange();
}
</code-example></div><p>The <code>logNameChange</code> method pushes name-change values into a <code>nameChangeLog</code> array.
Display that array at the bottom of the component template with this <code>*ngFor</code> binding:</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.html (Name change log)</h4></header><code-example language="html" format="">&lt;h4&gt;Name change log&lt;/h4&gt;
&lt;div *ngFor=&quot;let name of nameChangeLog&quot;&gt;{{name}}&lt;/div&gt;
</code-example></div><p>Return to the browser, select a hero (e.g, &quot;Magneta&quot;), and start typing in the <em>name</em> input box.
You should see a new name in the log after each keystroke.</p>
<h3 id="when-to-use-it">When to use it</h3>
<p>An interpolation binding is the easier way to <em>display</em> a name change.
Subscribing to an observable form control property is handy for triggering 
application logic <em>within</em> the component class.</p>
<div class="l-main-section"></div><a id="save"></a><h2 id="save-form-data">Save form data</h2>
<p>The <code>HeroDetailComponent</code> captures user input but it doesn&#39;t do anything with it.
In a real app, you&#39;d probably save those hero changes.
In a real app, you&#39;d also be able to revert unsaved changes and resume editing.
After you implement both features in this section, the form will look like this:</p>
<figure class="image-display"><img src="/resources/images/devguide/reactive-forms/save-revert-buttons.png" width="389px" alt="Form with save &amp; revert buttons"></figure><h3 id="save">Save</h3>
<p>In this sample application, when the user submits the form,
the <code>HeroDetailComponent</code> will pass an instance of the hero <em>data model</em>
to a save method on the injected <code>HeroService</code>.</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts (onSubmit)</h4></header><code-example language="ts" format="">onSubmit() {
  this.hero = this.prepareSaveHero();
  this.heroService.updateHero(this.hero).subscribe(/* error handling */);
  this.ngOnChanges();
}
</code-example></div><p>This original <code>hero</code> had the pre-save values. The user&#39;s changes are still in the <em>form model</em>.
So you create a new <code>hero</code> from a combination of original hero values (the <code>hero.id</code>)
and deep copies of the changed form model values, using the <code>prepareSaveHero</code> helper. </p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts (prepareSaveHero)</h4></header><code-example language="ts" format="">prepareSaveHero(): Hero {
  const formModel = this.heroForm.value;

  // deep copy of form model lairs
  const secretLairsDeepCopy: Address[] = formModel.secretLairs.map(
    (address: Address) =&gt; Object.assign({}, address)
  );

  // return new `Hero` object containing a combination of original hero value(s)
  // and deep copies of changed form model values
  const saveHero: Hero = {
    id: this.hero.id,
    name: formModel.name as string,
    // addresses: formModel.secretLairs // &lt;-- bad!
    addresses: secretLairsDeepCopy
  };
  return saveHero;
}
</code-example></div><div class="l-sub-section"><p><strong>Address deep copy</strong></p>
<p>Had you assigned the <code>formModel.secretLairs</code> to <code>saveHero.addresses</code> (see line commented out),
the addresses in <code>saveHero.addresses</code> array would be the same objects 
as the lairs in the <code>formModel.secretLairs</code>.
A user&#39;s subsequent changes to a lair street would mutate an address street in the <code>saveHero</code>.</p>
<p>The <code>prepareSaveHero</code> method makes copies of the form model&#39;s <code>secretLairs</code> objects so that can&#39;t happen.</p>
</div><h3 id="revert-cancel-changes-">Revert (cancel changes)</h3>
<p>The user cancels changes and reverts the form to the original state by pressing the <em>Revert</em> button.</p>
<p>Reverting is easy. Simply re-execute the <code>ngOnChanges</code> method that built the <em>form model</em> from the original, unchanged <code>hero</code> <em>data model</em>.</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.ts (revert)</h4></header><code-example language="ts" format="">revert() { this.ngOnChanges(); }
</code-example></div><h3 id="buttons">Buttons</h3>
<p>Add the &quot;Save&quot; and &quot;Revert&quot; buttons near the top of the component&#39;s template:</p>
<div class="code-example"><header><h4>src/app/hero-detail.component.html (Save and Revert buttons)</h4></header><code-example language="html" format="">&lt;form [formGroup]=&quot;heroForm&quot; (ngSubmit)=&quot;onSubmit()&quot; novalidate&gt;
  &lt;div style=&quot;margin-bottom: 1em&quot;&gt;
    &lt;button type=&quot;submit&quot;
            [disabled]=&quot;heroForm.pristine&quot; class=&quot;btn btn-success&quot;&gt;Save&lt;/button&gt; &amp;nbsp;
    &lt;button type=&quot;reset&quot; (click)=&quot;revert()&quot;
            [disabled]=&quot;heroForm.pristine&quot; class=&quot;btn btn-danger&quot;&gt;Revert&lt;/button&gt;
  &lt;/div&gt;

  &lt;!-- Hero Detail Controls --&gt;
  &lt;div class=&quot;form-group radio&quot;&gt;
    &lt;h4&gt;Super power:&lt;/h4&gt;
    &lt;label class=&quot;center-block&quot;&gt;&lt;input type=&quot;radio&quot; formControlName=&quot;power&quot; value=&quot;flight&quot;&gt;Flight&lt;/label&gt;
    &lt;label class=&quot;center-block&quot;&gt;&lt;input type=&quot;radio&quot; formControlName=&quot;power&quot; value=&quot;x-ray vision&quot;&gt;X-ray vision&lt;/label&gt;
    &lt;label class=&quot;center-block&quot;&gt;&lt;input type=&quot;radio&quot; formControlName=&quot;power&quot; value=&quot;strength&quot;&gt;Strength&lt;/label&gt;
  &lt;/div&gt;
  &lt;div class=&quot;checkbox&quot;&gt;
    &lt;label class=&quot;center-block&quot;&gt;
      &lt;input type=&quot;checkbox&quot; formControlName=&quot;sidekick&quot;&gt;I have a sidekick.
    &lt;/label&gt;
  &lt;/div&gt;
&lt;/form&gt;
</code-example></div><p>The buttons are disabled until the user &quot;dirties&quot; the form by changing a value in any of its form controls (<code>heroForm.dirty</code>).</p>
<p>Clicking a button of type <code>&quot;submit&quot;</code> triggers the <code>ngSubmit</code> event which calls the component&#39;s <code>onSubmit</code> method.
Clicking the revert button triggers a call to the component&#39;s <code>revert</code> method.
Users now can save or revert changes.</p>
<p>This is the final step in the demo.
Try the <live-example plnkr="final" title="Reactive Forms (final) in Plunker"></live-example>.</p>
<div class="l-main-section"></div><h2 id="conclusion">Conclusion</h2>
<p>This page covered:</p>
<ul>
<li>How to create a reactive form component and its corresponding template.</li>
<li>How to use <code>FormBuilder</code> to simplify coding a reactive form.</li>
<li>Grouping <code>FormControls</code>.</li>
<li>Inspecting <code>FormControl</code> properties.</li>
<li>Setting data with <code>patchValue</code> and <code>setValue</code>.</li>
<li>Adding groups dynamically with <code>FormArray</code>.</li>
<li>Observing changes to the value of a <code>FormControl</code>.</li>
<li>Saving form changes.</li>
</ul>
<a id="source-code"></a><p>The key files of the final version are as follows:</p>
<code-tabs><code-pane language="ts" name="src/app/app.component.ts" format="linenums">import { Component } from &#39;@angular/core&#39;;

@Component({
  selector: &#39;my-app&#39;,
  template: `
  &lt;div class=&quot;container&quot;&gt;
    &lt;h1&gt;Reactive Forms&lt;/h1&gt;
    &lt;hero-list&gt;&lt;/hero-list&gt;
  &lt;/div&gt;`
})
export class AppComponent { }
</code-pane><code-pane language="ts" name="src/app/app.module.ts" format="linenums">import { NgModule }            from &#39;@angular/core&#39;;
import { BrowserModule }       from &#39;@angular/platform-browser&#39;;
import { ReactiveFormsModule } from &#39;@angular/forms&#39;;  // &lt;-- #1 import module

import { AppComponent }        from &#39;./app.component&#39;;
import { HeroDetailComponent } from &#39;./hero-detail.component&#39;; // &lt;-- #1 import component
import { HeroListComponent }   from &#39;./hero-list.component&#39;;

import { HeroService }         from &#39;./hero.service&#39;; //  &lt;-- #1 import service

@NgModule({
  imports: [
    BrowserModule,
    ReactiveFormsModule // &lt;-- #2 add to Angular module imports
  ],
  declarations: [
    AppComponent,
    HeroDetailComponent, // &lt;-- #3 declare app component
    HeroListComponent
  ],
  exports: [ // export for the DemoModule
    AppComponent,
    HeroDetailComponent,
    HeroListComponent
  ],
  providers: [ HeroService ], // &lt;-- #4 provide HeroService
  bootstrap: [ AppComponent ]
})
export class AppModule { }
</code-pane><code-pane language="ts" name="src/app/hero-detail.component.ts" format="linenums">import { Component, Input, OnChanges }       from &#39;@angular/core&#39;;
import { FormArray, FormBuilder, FormGroup } from &#39;@angular/forms&#39;;

import { Address, Hero, states } from &#39;./data-model&#39;;
import { HeroService }           from &#39;./hero.service&#39;;

@Component({
  selector: &#39;hero-detail&#39;,
  templateUrl: &#39;./hero-detail.component.html&#39;
})
export class HeroDetailComponent implements OnChanges {
  @Input() hero: Hero;

  heroForm: FormGroup;
  nameChangeLog: string[] = [];
  states = states;

  constructor(
    private fb: FormBuilder,
    private heroService: HeroService) {

    this.createForm();
    this.logNameChange();
  }

  createForm() {
    this.heroForm = this.fb.group({
      name: &#39;&#39;,
      secretLairs: this.fb.array([]),
      power: &#39;&#39;,
      sidekick: &#39;&#39;
    });
  }

  ngOnChanges() {
    this.heroForm.reset({
      name: this.hero.name
    });
    this.setAddresses(this.hero.addresses);
  }

  get secretLairs(): FormArray {
    return this.heroForm.get(&#39;secretLairs&#39;) as FormArray;
  };

  setAddresses(addresses: Address[]) {
    const addressFGs = addresses.map(address =&gt; this.fb.group(address));
    const addressFormArray = this.fb.array(addressFGs);
    this.heroForm.setControl(&#39;secretLairs&#39;, addressFormArray);
  }

  addLair() {
    this.secretLairs.push(this.fb.group(new Address()));
  }

  onSubmit() {
    this.hero = this.prepareSaveHero();
    this.heroService.updateHero(this.hero).subscribe(/* error handling */);
    this.ngOnChanges();
  }

  prepareSaveHero(): Hero {
    const formModel = this.heroForm.value;

    // deep copy of form model lairs
    const secretLairsDeepCopy: Address[] = formModel.secretLairs.map(
      (address: Address) =&gt; Object.assign({}, address)
    );

    // return new `Hero` object containing a combination of original hero value(s)
    // and deep copies of changed form model values
    const saveHero: Hero = {
      id: this.hero.id,
      name: formModel.name as string,
      // addresses: formModel.secretLairs // &lt;-- bad!
      addresses: secretLairsDeepCopy
    };
    return saveHero;
  }

  revert() { this.ngOnChanges(); }

  logNameChange() {
    const nameControl = this.heroForm.get(&#39;name&#39;);
    nameControl.valueChanges.forEach(
      (value: string) =&gt; this.nameChangeLog.push(value)
    );
  }
}
</code-pane><code-pane language="html" name="src/app/hero-detail.component.html" format="linenums">&lt;form [formGroup]=&quot;heroForm&quot; (ngSubmit)=&quot;onSubmit()&quot; novalidate&gt;
  &lt;div style=&quot;margin-bottom: 1em&quot;&gt;
    &lt;button type=&quot;submit&quot;
            [disabled]=&quot;heroForm.pristine&quot; class=&quot;btn btn-success&quot;&gt;Save&lt;/button&gt; &amp;nbsp;
    &lt;button type=&quot;reset&quot; (click)=&quot;revert()&quot;
            [disabled]=&quot;heroForm.pristine&quot; class=&quot;btn btn-danger&quot;&gt;Revert&lt;/button&gt;
  &lt;/div&gt;

  &lt;!-- Hero Detail Controls --&gt;
  &lt;div class=&quot;form-group&quot;&gt;
      &lt;label class=&quot;center-block&quot;&gt;Name:
        &lt;input class=&quot;form-control&quot; formControlName=&quot;name&quot;&gt;
      &lt;/label&gt;
  &lt;/div&gt;

  &lt;div formArrayName=&quot;secretLairs&quot; class=&quot;well well-lg&quot;&gt;
    &lt;div *ngFor=&quot;let address of secretLairs.controls; let i=index&quot; [formGroupName]=&quot;i&quot; &gt;
      &lt;!-- The repeated address template --&gt;
      &lt;h4&gt;Address #{{i + 1}}&lt;/h4&gt;
      &lt;div style=&quot;margin-left: 1em;&quot;&gt;
        &lt;div class=&quot;form-group&quot;&gt;
          &lt;label class=&quot;center-block&quot;&gt;Street:
            &lt;input class=&quot;form-control&quot; formControlName=&quot;street&quot;&gt;
          &lt;/label&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group&quot;&gt;
          &lt;label class=&quot;center-block&quot;&gt;City:
            &lt;input class=&quot;form-control&quot; formControlName=&quot;city&quot;&gt;
          &lt;/label&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group&quot;&gt;
          &lt;label class=&quot;center-block&quot;&gt;State:
            &lt;select class=&quot;form-control&quot; formControlName=&quot;state&quot;&gt;
              &lt;option *ngFor=&quot;let state of states&quot; [value]=&quot;state&quot;&gt;{{state}}&lt;/option&gt;
            &lt;/select&gt;
          &lt;/label&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group&quot;&gt;
          &lt;label class=&quot;center-block&quot;&gt;Zip Code:
            &lt;input class=&quot;form-control&quot; formControlName=&quot;zip&quot;&gt;
          &lt;/label&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;br&gt;
      &lt;!-- End of the repeated address template --&gt;
    &lt;/div&gt;
    &lt;button (click)=&quot;addLair()&quot; type=&quot;button&quot;&gt;Add a Secret Lair&lt;/button&gt;
  &lt;/div&gt;
  &lt;div class=&quot;form-group radio&quot;&gt;
    &lt;h4&gt;Super power:&lt;/h4&gt;
    &lt;label class=&quot;center-block&quot;&gt;&lt;input type=&quot;radio&quot; formControlName=&quot;power&quot; value=&quot;flight&quot;&gt;Flight&lt;/label&gt;
    &lt;label class=&quot;center-block&quot;&gt;&lt;input type=&quot;radio&quot; formControlName=&quot;power&quot; value=&quot;x-ray vision&quot;&gt;X-ray vision&lt;/label&gt;
    &lt;label class=&quot;center-block&quot;&gt;&lt;input type=&quot;radio&quot; formControlName=&quot;power&quot; value=&quot;strength&quot;&gt;Strength&lt;/label&gt;
  &lt;/div&gt;
  &lt;div class=&quot;checkbox&quot;&gt;
    &lt;label class=&quot;center-block&quot;&gt;
      &lt;input type=&quot;checkbox&quot; formControlName=&quot;sidekick&quot;&gt;I have a sidekick.
    &lt;/label&gt;
  &lt;/div&gt;
&lt;/form&gt;

&lt;p&gt;heroForm value: {{ heroForm.value | json}}&lt;/p&gt;

&lt;h4&gt;Name change log&lt;/h4&gt;
&lt;div *ngFor=&quot;let name of nameChangeLog&quot;&gt;{{name}}&lt;/div&gt;
</code-pane><code-pane language="html" name="src/app/hero-list.component.html" format="linenums">&lt;h3 *ngIf=&quot;isLoading&quot;&gt;&lt;i&gt;Loading heroes ... &lt;/i&gt;&lt;/h3&gt;
&lt;h3 *ngIf=&quot;!isLoading&quot;&gt;Select a hero:&lt;/h3&gt;

&lt;nav&gt;
  &lt;button (click)=&quot;getHeroes()&quot; class=&quot;btn btn-primary&quot;&gt;Refresh&lt;/button&gt;
  &lt;a *ngFor=&quot;let hero of heroes | async&quot; (click)=&quot;select(hero)&quot;&gt;{{hero.name}}&lt;/a&gt;
&lt;/nav&gt;

&lt;div *ngIf=&quot;selectedHero&quot;&gt;
  &lt;hr&gt;
  &lt;h2&gt;Hero Detail&lt;/h2&gt;
  &lt;h3&gt;Editing: {{selectedHero.name}}&lt;/h3&gt;
  &lt;hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/hero-detail&gt;
&lt;/div&gt;
</code-pane><code-pane language="ts" name="src/app/hero-list.component.ts" format="linenums">import { Component, OnInit } from &#39;@angular/core&#39;;
import { Observable }        from &#39;rxjs/Observable&#39;;
import &#39;rxjs/add/operator/finally&#39;;

import { Hero }        from &#39;./data-model&#39;;
import { HeroService } from &#39;./hero.service&#39;;

@Component({
  selector: &#39;hero-list&#39;,
  templateUrl: &#39;./hero-list.component.html&#39;
})
export class HeroListComponent implements OnInit {
  heroes: Observable&lt;Hero[]&gt;;
  isLoading = false;
  selectedHero: Hero;

  constructor(private heroService: HeroService) { }

  ngOnInit() { this.getHeroes(); }

  getHeroes() {
    this.isLoading = true;
    this.heroes = this.heroService.getHeroes()
                      // Todo: error handling
                      .finally(() =&gt; this.isLoading = false);
    this.selectedHero = undefined;
  }

  select(hero: Hero) { this.selectedHero = hero; }
}
</code-pane><code-pane language="ts" name="src/app/data-model.ts" format="linenums">export class Hero {
  id = 0;
  name = &#39;&#39;;
  addresses: Address[];
}

export class Address {
  street = &#39;&#39;;
  city   = &#39;&#39;;
  state  = &#39;&#39;;
  zip    = &#39;&#39;;
}

export const heroes: Hero[] = [
  {
    id: 1,
    name: &#39;Whirlwind&#39;,
    addresses: [
      {street: &#39;123 Main&#39;,  city: &#39;Anywhere&#39;, state: &#39;CA&#39;,  zip: &#39;94801&#39;},
      {street: &#39;456 Maple&#39;, city: &#39;Somewhere&#39;, state: &#39;VA&#39;, zip: &#39;23226&#39;},
    ]
  },
  {
    id: 2,
    name: &#39;Bombastic&#39;,
    addresses: [
      {street: &#39;789 Elm&#39;,  city: &#39;Smallville&#39;, state: &#39;OH&#39;,  zip: &#39;04501&#39;},
    ]
  },
  {
    id: 3,
    name: &#39;Magneta&#39;,
    addresses: [ ]
  },
];

export const states = [&#39;CA&#39;, &#39;MD&#39;, &#39;OH&#39;, &#39;VA&#39;];
</code-pane><code-pane language="ts
   " name="src/app/hero.service.ts" format="linenums">import { Injectable } from &#39;@angular/core&#39;;

import { Observable } from &#39;rxjs/Observable&#39;;
import { of }         from &#39;rxjs/observable/of&#39;;
import &#39;rxjs/add/operator/delay&#39;;

import { Hero, heroes } from &#39;./data-model&#39;;

@Injectable()
export class HeroService {

  delayMs = 500;

  // Fake server get; assume nothing can go wrong
  getHeroes(): Observable&lt;Hero[]&gt; {
    return of(heroes).delay(this.delayMs); // simulate latency with delay
  }

  // Fake server update; assume nothing can go wrong
  updateHero(hero: Hero): Observable&lt;Hero&gt;  {
    const oldHero = heroes.find(h =&gt; h.id === hero.id);
    const newHero = Object.assign(oldHero, hero); // Demo: mutate cached hero
    return of(newHero).delay(this.delayMs); // simulate latency with delay
  }
}
</code-pane></code-tabs><p>You can download the complete source for all steps in this guide
from the <live-example title="Reactive Forms Demo in Plunker">Reactive Forms Demo</live-example> live example.</p><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></article><div data-swiftype-index="false" class="main-footer"><nav class="background-midnight grid-fluid"><div class="c3 main-footer-branding"><div class="logo-inverse-large"></div></div><div class="c2"><h3 class="text-headline">RESOURCES</h3><ul class="text-body"><!-- TODO: (ericjim) make a libraries page to showcase all angular libraries--><!--li <a href="/libraries.html">Libraries</a>--><li><a href="/about/">About</a></li><li><a href="/resources/#Education">Books & Training</a></li><li><a href="/resources/">Tools & Libraries</a></li><li><a href="/resources/">Community</a></li><li><a href="/presskit.html">Press Kit</a></li></ul></div><div class="c2"><h3 class="text-headline">HELP</h3><ul class="text-body"><li><a href="http://stackoverflow.com/questions/tagged/angular2">Stack Overflow</a></li><li><a href="https://gitter.im/angular/angular">Gitter</a></li><li><a href="https://groups.google.com/forum/#!forum/angular"> Google Group</a></li><li><a href="https://github.com/angular/angular/issues"> Report Issues</a></li><li><a class="footer-feedback" ng-click="appCtrl.openFeedback()" aria-label="Submit feedback on this page"> Site Feedback</a></li></ul></div><div class="c2"><h3 class="text-headline">COMMUNITY</h3><ul class="text-body"><li><a href="/events.html">Events</a></li><li><a href="http://www.meetup.com/topics/angularjs/">Meetups</a></li><li><a href="https://twitter.com/angular"> Twitter</a></li><li><a href="https://github.com/angular/angular"> GitHub</a></li><li><a href="/contribute.html"> Contribute</a></li></ul></div><div class="c2"><h3 class="text-headline">LANGUAGES</h3><ul class="text-body"><li><a href="https://angular.cn/">中文版</a></li></ul></div></nav><footer class="background-midnight"><small class="text-caption">Powered by Google ©2010-2017. Code licensed under an <a href="/license">MIT-style License</a>. Documentation licensed under <a href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.</small><a aria-label="View Style Guide" href="/docs/ts/latest/styleguide.html" title="Style Guide" class="styleguide-trigger"><span class="icon-favorite"></span></a></footer></div><!-- VENDORS --><script src="/resources/js/vendor/prettify.js"></script><script src="/resources/js/vendor/lang-basic.js"></script><script src="/resources/js/vendor/lang-dart.js"></script><script src="/resources/js/vendor/lodash.js"></script><script src="/resources/js/vendor/clipboard.min.js"></script><!-- Angular Material Dependencies --><script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.0/angular.min.js"></script><script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.0/angular-animate.min.js"></script><script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.0/angular-aria.min.js"></script><script src="https://ajax.googleapis.com/ajax/libs/angular_material/1.0.0/angular-material.min.js"></script><!-- Firebase -->
<script src="https://cdn.firebase.com/js/client/2.2.4/firebase.js"></script>
<!-- AngularFire -->
<script src="https://cdn.firebase.com/libs/angularfire/1.2.0/angularfire.min.js"></script>
<!-- Angular.io Site JS --><script src="/resources/js/site.js"></script><script src="/resources/js/util.js"></script><script src="/resources/js/controllers/app-controller.js"></script><script src="/resources/js/controllers/resources-controller.js"></script><script src="/resources/js/directives/cheatsheet.js"></script><script src="/resources/js/directives/api-list.js"></script><script src="/resources/js/directives/bio.js"></script><script src="/resources/js/directives/bold.js"></script><script src="/resources/js/directives/announcement-bar.js"></script><script src="/resources/js/directives/code.js"></script><script src="/resources/js/directives/copy.js"></script><script src="/resources/js/directives/code-tabs.js"></script><script src="/resources/js/directives/code-pane.js"></script><script src="/resources/js/directives/code-example.js"></script><script src="/resources/js/directives/if-docs.js"></script><script src="/resources/js/directives/live-example.js"></script><script src="/resources/js/directives/ngio-ex-path.js"></script><script src="/resources/js/directives/scroll-y-offset-element.js"></script><!-- GA --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-8594346-15', 'auto');
ga('send', 'pageview')
</script><!-- SWIFTYPE --><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

_st('install','VsuU7kH5Hnnj9tfyNvfK','2.0.0');

</script><!-- Google Feedback --><script src="//www.gstatic.com/feedback/api.js" type="text/javascript"></script><!-- Twitter Widget --><script>(function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}})(document,"script","twitter-wjs");</script></body></html>